"""
Rotation of Spherical Harmonics Invariants generated by method of Tensor Contraction 

"""
import cmath
import math
import pandas
import os
import sys
import numpy as np
import scipy.io
from matplotlib import pyplot as pot
import matplotlib.pyplot as plt
import matplotlib as mpl
from mpl_toolkits.mplot3d import Axes3D
from sympy.physics.quantum.cg import CG
from sympy import S
import pyshtools as shtools
import nrrd

##################################################################
#--------------loading the input .nrrd file-------------------#

train_data, options = nrrd.read('one-train-odfs.nrrd')

print train_data.shape #(15,1000)

x = train_data.transpose()

df = pandas.DataFrame(x)

print "transposed raw data : ", df.shape

##################################################################
#-----This function gives rotated SH coeff. coming from Cx-------#

def SHRotations(coeff):

    #---- input parameters ----#

    lmax = 4     #order of the SH
    alpha, beta, gamma = 165., 175., 100. #angles for rotation

    #--derived parameters --#
    angles = np.radians([alpha, beta, gamma])
    dj_matrix = shtools.djpi2(lmax)

    return shtools.SHRotateRealCoef(coeff, angles, dj_matrix)

################################################################################
#-----This function converts the values into complex and returns Cx------#

def Conv_to_comp(array):
    Cx=[0 for i in range(len(array))]
    i=1
    c = []
    for i in range(0,5):
        for j in range(-2*i,2*i+1):
            c.append(j)
    for k in range(0,len(array)):
        if (c[k]==0):
            Cx[k]=array[k]
        elif (c[k]>0):
            Cx[k]=1/math.sqrt(2)*(array[k]+cmath.sqrt(-1)*array[k-2*c[k]])
        else:
            Cx[k]=1/math.sqrt(2)*math.pow((-1),c[k])*(array[k+2*abs(c[k])]-cmath.sqrt(-1)*array[k])

    return Cx

def Conv_to_real(array):
    Cx=[0 for i in range(len(array))]
    i=1
    c = []
    for i in range(0,5):
        for j in range(-2*i,2*i+1):
            c.append(j)
    for k in range(0,len(array)):
        if (c[k]==0):
            Cx[k]=array[k].real
        elif (c[k]>0):
            Cx[k]=(array[k].real)*math.sqrt(2)
        else:
            Cx[k]=-math.pow((-1),c[k])*(array[k].imag)*math.sqrt(2)

    return Cx

def BackToComplex(array_real_imag):
    #print array_real_imag[0]  #real
    #print array_real_imag[1]  #imag
    initial_form=range(15)
    k=0
    for i in range(0,5):
        for j in range(0,i+1):
            initial_form[k]=complex(array_real_imag[0][i][j],-array_real_imag[1][i][j])
            if (j > 0):
                initial_form[k]/=math.sqrt(2)     # Check for sign difference
            k=k+1

    in_f=range(15)
    for i in range(0,len(in_f)):
        in_f[i]=initial_form[i]
    
    in_f[1]=np.conj(initial_form[5])
    in_f[2]=-np.conj(initial_form[4])

    in_f[6]=np.conj(initial_form[14])
    in_f[7]=-np.conj(initial_form[13])
    in_f[8]=np.conj(initial_form[12])
    in_f[9]=-np.conj(initial_form[11])

    return in_f

def Creating_Matrix(a):
    '''
    e.g : 

    1 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 
    4 5 6 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 
    11 12 13 14 15...

    '''
    mat=[[0 for x in range(5)] for x in range(5)]

    k=0
    for i in range(0,5):
        for j in range(0,i+1):
            if (i % 2) == 0:   # Michael 
                mat[i][j]=a[k]
                
                if (j > 0):
                    mat[i][j]*=math.sqrt(2)
            k=k+1

    return mat

def Rotation(Cx0): 

    #---Rotation of Cx---#

    # Cx is an array of 15 elements, each of them is in form of (a+ib)
    RealPart=[]
    for i in range(0,len(Cx0)):
        RealPart.append(Cx0[i].real)

    rp=Creating_Matrix(RealPart)


    ImagPart=[]
    for i in range(0,len(Cx0)):
        ImagPart.append(-Cx0[i].imag)  #Sign covention for the SH library convention sign diffrence 

    ip=Creating_Matrix(ImagPart)
    
    #make it to the form of input which we can put into SHRotation
    SH_coeff=[[rp[0],rp[1],rp[2],rp[3],rp[4]],[ip[0],ip[1],ip[2],ip[3],ip[4]]]

    rotated_array=SHRotations(SH_coeff)
    final_rotated=BackToComplex(rotated_array)

    return final_rotated

#working with invariants    
Inv1 = [[0 for i in xrange(3)] for i in xrange(1000)]
for j in range(0, len(x)):
    Cx = Conv_to_comp(x[j])

    Invariants1 = [0 for i in range(3)]
    Invariants1[0] = math.pow(Cx[0],2)
    sum, sum1, sum2, sum3 = 0, 0, 0, 0
    for i in range(1, 6):
        sum = sum + Cx[i]*np.conjugate(Cx[i])
    for i in range(6, 15):
        sum1 = sum1 + Cx[i]*np.conjugate(Cx[i])

    Invariants1[1] = sum
    Invariants1[2] = sum1
    Inv1[j]=Invariants1

print "\n\n\nClassical 4th-order invariants (power spectrum) : I(0), I(2), I(4) "

df1 = pandas.DataFrame(Inv1)

print df1
#print df1.shape


def CalcTensor(Cx, l, l1, l2):
    Ten = [[0 for x in range(1)] for x in range(2*l+1)]
    result = 0
        #if (l>(l1+l2) or l<abs(l1-l2)):
        # print('Invalid tensor')
        # Ten = -1
    if(l1==0):
        s1 = 1
    elif(l1==2):
        s1 = 4
    elif(l1==4):
        s1 = 11
    elif(l1==6):
        s1 = 22
    elif(l1==8):
        s1 = 37
    
    if(l2==0):
        s2 = 1
    elif(l2==2):
        s2 = 4
    elif(l2==4):
        s2 = 11
    elif(l2==6):
        s2 = 22
    elif(l2==8):
        s2 = 37

    #column of length 2l+1
    jj = 0
    for m in range(-l,l+1):
        for m1 in range(-l1,l1+1):
            for m2 in range(-l2,l2+1):
                el=float(CG(l1,m1,l2,m2,l,m).doit())
                Ten[jj][0]=Ten[jj][0]+el*np.conjugate(Cx[m1+s1-1])*np.conjugate(Cx[m2+s2-1])
        jj = jj + 1
    return Ten

Mas1 = [[0 for i in xrange(3)] for i in xrange(1000)]

for j in range(0, len(x)):
    Invar2 = [0 for i in range(3)]
    Cx1 = Conv_to_comp(x[j])
    Invar2[0]=Cx1[0]*CalcTensor(Cx1,0,2,2)[0][0]
    arr= np.array(CalcTensor(Cx1,2,2,2)).transpose()
    
    Invar2[1]=0
    count=0
    
    for i in range(1, 6):
        Invar2[1] = Invar2[1] + (np.conjugate(Cx1[i]))*np.conjugate(arr[0][count])
        count = count+1

    count=0
    Invar2[2]=0
    arr1= np.array(CalcTensor(Cx1,4,2,2)).transpose()
    for i in range(6, 15):
        Invar2[2] = Invar2[2] + (np.conjugate(Cx1[i]))*np.conjugate(arr1[0][count])
        count = count+1

    Mas1[j]=Invar2

Mas1=np.array(Mas1)

print "\n\n\n4th-order tensor contraction invariants : J(0,2,2), J(2,2,2), J(4,2,2)"

df2 = pandas.DataFrame(Mas1)

print df2
#print df2.shape